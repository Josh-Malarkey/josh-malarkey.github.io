const RESUME_DATA = {
    "Jobs": [
        {
            "Company": "Vivino",
            "Job Title": "Senior Analytics Manager",
            "Start Month": "Mar-2025",
            "End Month": "Present",
            "Accomplishments": [
                {
                    "Description": "Consulted with Executive leadership to implement a company wide OKR framework",
                    "Categories": ["Communication", "Leadership"]
                },
                {
                    "Description": "Collaborated with Customer Success team to develop data product strategy that increased ARR by $450K",
                    "Categories": ["Communication", "Teamwork"]
                },
            ],
            "color": "rgba(0, 100, 100, 0.5)",
            "icon": "fa-glass"
        },
        {
            "Company": "Vivino",
            "Job Title": "Analytics Manager",
            "Start Month": "Mar-2022",
            "End Month": "Mar-2025",
            "Accomplishments": [
                {
                    "Description": "Optimized Looker/dbt models to deliver ta 7x improvement in load-time for client facing dashboards",
                    "Categories": ["Ownership", "Problem Solving"]
                },
                {
                    "Description": "Implemented fault tolerant data pipelines & data models to reduce average query time by 82%",
                    "Categories": ["Ownership", "Problem Solving"]
                }
            ],
            "color": "rgba(0, 100, 100, 0.5)",
            "icon": "fa-glass"
        },
        {
            "Company": "Wells Fargo CTS/Computershare",
            "Job Title": "Senior Analyst",
            "Start Month": "Dec-2019",
            "End Month": "Mar-2022",
            "Accomplishments": [
                {
                    "Description": "Optimized T-SQL scripts to improve transaction processing time by 85%",
                    "Categories": ["Problem Solving"]
                },
                {
                    "Description": "CEstablished documentation standards and training protocols for internal systems across 60-person department",
                    "Categories": ["Leadership", "Communication"]
                }
            ],
            "color": "rgba(25, 100, 126, 0.5)",
            "icon": "fa-cogs"
        },
        {
            "Company": "Self Employed",
            "Job Title": "Web Designer",
            "Start Month": "May-2018",
            "End Month": "Dec-2019",
            "Accomplishments": [
                {
                    "Description": "Created a small business (LLC) and website with original photo, video, and informational content",
                    "Categories": ["Ownership", "Continuous Learning"],
                    "Link": {
                                "text": "small business (LLC) and website",
                                "url": "http://www.worldlywander.com"
                            }
                },
                {
                    "Description": "Implemented SEO strategy using WordPress/Google Analytics to increase web traffic and monitor user engagement stats",
                    "Categories": ["Continuous Learning", "Problem Solving"]
                }
            ],
            "color": "rgba(129, 178, 154, 0.5)",
            "icon": "fa-laptop"
        },
        {
            "Company": "Wells Fargo",
            "Job Title": "Analytics Consultant",
            "Start Month": "Mar-2016",
            "End Month": "May-2018",
            "Accomplishments": [
                {
                    "Description": "Designed and implemented a custom ticketing database to manage >100 monthly support requests",
                    "Categories": ["Ownership", "Problem Solving"]
                },
                {
                    "Description": "Key contributor to 6-person Agile team supporting data warehouse migration to SQL Server",
                    "Categories": ["Ownership", "Problem Solving"]
                }
            ],
            "color": "rgba(1, 22, 30, 0.5)",
            "icon": "fa-home"
        },
        {
            "Company": "Wells Fargo",
            "Job Title": "Analyst",
            "Start Month": "Jan-2015",
            "End Month": "Mar-2016",
            "Accomplishments": [
                {
                    "Description": "Automated data cleaning workflow to reduce new client onboarding timeline from 7 days to 5 days",
                    "Categories": ["Communication", "Problem Solving"]
                }
            ],
            "color": "rgba(1, 22, 30, 0.5)",
            "icon": "fa-home"
        }
    ],
    "Education": {
        "Degrees": [
            {
                "School": "Johns Hopkins University; Whiting School of Engineering",
                "Degree": "Graduate Certificate",
                "Field of Study": "Information Systems Engineering",
                "Start Month": "Jan-2021",
                "End Month": "May-2024"
            },
            {
                "School": "Johns Hopkins University; Whiting School of Engineering",
                "Degree": "Master of Science",
                "Field of Study": "Data Science",
                "Start Month": "Aug-2020",
                "End Month": "Dec-2023"
            },
            {
                "School": "St. Mary's College of Maryland",
                "Degree": "Bachelor of Arts",
                "Field of Study": "Economics, Mathematics Minor",
                "Start Month": "Aug-2010",
                "End Month": "May-2014"
            }
        ],
        "Certifications": [
            {
                "Organization": "Coursera",
                "Name": "Data Ingestion, Exploration & Visualization in Qlik Sense",
                "Issue Date": "Apr-2024",
                "Credential ID": "4KPYVWES7TU5",
                "Credential URL": "https://www.coursera.org/account/accomplishments/certificate/4KPYVWES7TU5"
            },
            {
                "Organization": "Coursera",
                "Name": "Data Science with Databricks Specialization",
                "Issue Date": "Feb-2024",
                "Credential ID": "SLTCQUKKCD2T",
                "Credential URL": "https://www.coursera.org/account/accomplishments/certificate/SLTCQUKKCD2T"
            },
            {
                "Organization": "Coursera",
                "Name": "Renewable Energy Specialization",
                "Issue Date": "Sept-2022",
                "Credential ID": "LALRJ3K6N59S",
                "Credential URL": "https://www.coursera.org/account/accomplishments/certificate/LALRJ3K6N59S"
            }
        ]
    },
    "Skills": {
        "Languages": {
            "SQL": "Expert",
            "LookML": "Expert",
            "Python": "Advanced",
            "Jinja": "Intermediate",
            "CSS/HTML/JS": "Basic",
        },
        "Tools": {
            "Data Modelling": ["Looker/LookML", "dbt", "Excel", "SQL"],
            "Data Visualization": ["Looker", "Tableau", "Python (Dash, Plotly, Seaborn, Streamlit)", "Qliksense"],
            "Statistical Analysis": ["Bayesian Inference", "Excel", "Python (Numpy, Pandas, SciPy)", "SQL"],
            "Data Storage": ["AWS Lambda", "AWS Redshift", "AWS S3", "Databricks", "DuckDB", "SQL Server", "SQLite"],
            "Data Pipelines": ["AWS Glue", "Prefect", "Python (Pandas)"],
            "A/B Testing": ["Excel", "Mixpanel", "Python (SciPy)"],
            "Frontend Design": ["Bootstrap", "Figma", "WordPress"]
        },
        "Technical Skills": {
            "Data Modelling": "Expert",
            "Data Visualization": "Expert",
            "Statistical Analysis": "Expert",
            "Data Storage": "Advanced",
            "Data Pipelines": "Intermediate",
            "A/B Testing": "Basic",
            "Frontend Design": "Basic"
        }
    }
};

// UTILITY FUNCTIONS
function parseDate(dateStr) {
    if (dateStr === "Present") return new Date();
    const [month, year] = dateStr.split('-');
    const monthMap = {
        'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
        'Jul': 6, 'Aug': 7, 'Sep': 8, 'Sept': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
    };
    return new Date(parseInt(year), monthMap[month]);
}

function calculateDuration(startDate, endDate) {
    const start = parseDate(startDate);
    const end = parseDate(endDate);
    return ((end - start) / (1000 * 60 * 60 * 24 * 365.25));
}

function skillToNumber(skill) {
    const mapping = {
        'Beginner': 1, 'Basic': 2, 'Intermediate': 3, 'Advanced': 4, 'Expert': 5
    };
    return mapping[skill] || 0;
}

// CHART CREATION FUNCTIONS

function createJobsChart() {
    // Process jobs data for stacked horizontal bar chart
    const processedJobs = [];
    
    RESUME_DATA.Jobs.forEach(job => {
        const duration = calculateDuration(job["Start Month"], job["End Month"]);
        processedJobs.push({
            company: job.Company,
            title: job["Job Title"],
            duration: duration,
            startDate: job["Start Month"],
            endDate: job["End Month"]
        });
    });

    // Group by company and sort by start date (most recent first)
    const companiesMap = {};
    processedJobs.forEach(job => {
        if (!companiesMap[job.company]) {
            companiesMap[job.company] = [];
        }
        companiesMap[job.company].push(job);
    });

    // Sort companies by most recent start date (most recent first)
    const sortedCompanies = Object.keys(companiesMap).sort((a, b) => {
        const aLatest = Math.max(...companiesMap[a].map(job => parseDate(job.startDate)));
        const bLatest = Math.max(...companiesMap[b].map(job => parseDate(job.startDate)));
        return aLatest - bLatest;
    });

    const defaultOpacity = 0.8
    const traces = [];
    const colors = [
        `rgba(1, 22, 30, ${defaultOpacity})`,      // Light Blue/Gray
        `rgba(129, 178, 154, ${defaultOpacity})`,  // Light Green
        `rgba(25, 100, 126, ${defaultOpacity})`,   // Sage Green
        `rgba(0, 100, 100, ${defaultOpacity})`   // Dark Blue/Gray
    ];


    sortedCompanies.forEach((company, companyIndex) => {
        const jobs = companiesMap[company].sort((a, b) => parseDate(a.startDate) - parseDate(b.startDate));
        
        jobs.forEach((job, jobIndex) => {
            traces.push({
                x: [job.duration],
                y: [company],
                type: 'bar',
                orientation: 'h',
                name: job.title,
                text: `${job.title}<br>${job.duration.toFixed(1)} years<br>`,
                textposition: 'inside',
                marker: {
                    color: colors[companyIndex % colors.length],
                    opacity: defaultOpacity - (jobIndex * 0.2)
                },
                hovertemplate: `<b>${job.title}</b><br>Company: ${company}<br>Duration: ${job.duration.toFixed(1)} years<br>Period: ${job.startDate} - ${job.endDate}<extra></extra>`
            });
        });
    });

    const layout = {
        title: '',
        xaxis: { 
            title: 'Duration (Years)', 
            color: '#535353',
            gridcolor: 'rgba(255,255,255,0.2)'
        },
        yaxis: { 
            title: '', 
            color: '#535353',
            categoryorder: 'array',
            categoryarray: sortedCompanies
        },
        barmode: 'stack',
        plot_bgcolor: 'rgba(0,0,0,0)',
        paper_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#535353', size: 16 },
        showlegend: false,
        legend: {
            orientation: 'h',
            y: -0.2,
            font: { color: '#535353' }
        },
        margin: { l: 120, r: 50, t: 50, b: 100 }
    };

    const config = { responsive: true, displayModeBar: false };
    Plotly.newPlot('jobsChart', traces, layout, config);
}

function createSkillsCharts() {
    // Languages Radar Chart
    const languages = Object.keys(RESUME_DATA.Skills.Languages);
    const languageValues = Object.values(RESUME_DATA.Skills.Languages).map(skillToNumber);

    const languageTrace = {
        type: 'scatterpolar',
        r: languageValues,
        theta: languages,
        fill: 'toself',
        name: 'Proficiency Level',
        line: {color: '#c5dac8', width: 3 },
        marker: {color: '#37563c', width: 3 }
    };

    const languageLayout = {
        polar: {
            radialaxis: {
                visible: true,
                range: [0, 5],
                tickvals: [1, 2, 3, 4, 5],
                ticktext: ['Beginner', 'Basic', 'Intermediate', 'Advanced', 'Expert'],
                color: '#535353',
                gridcolor: "#ecf0f1",
                tickcolor: "#ecf0f1",
                linecolor: "#929292",
                color: "black"
            },
            angularaxis: { color: 'black' }
        },
        showlegend: false,
        plot_bgcolor: 'rgba(0,0,0,0)',
        paper_bgcolor: 'rgba(0,0,0,0)',
        font: { color: 'black', size: '1.2em' },
        margin: { l: 50, r: 50, t: 50, b: 50 }
    };

    // Technical Skills Radar Chart
    const technicalSkills = Object.keys(RESUME_DATA.Skills["Technical Skills"]);
    const technicalValues = Object.values(RESUME_DATA.Skills["Technical Skills"]).map(skillToNumber);

    const technicalTrace = {
        type: 'scatterpolar',
        r: technicalValues,
        theta: technicalSkills.map(skill => 
            skill.length > 15 ? skill.replace(/(.{1,15})\s+/g, '$1<br>') : skill
        ),
        fill: 'toself',
        name: 'Proficiency Level',
        line: {color: '#c7dde3', width: 3 },
        marker: {color: '#1f363d', width: 3 }
    };

    const technicalLayout = {
        polar: {
            radialaxis: {
                visible: true,
                range: [0, 5],
                tickvals: [1, 2, 3, 4, 5],
                ticktext: ['Beginner', 'Basic', 'Intermediate', 'Advanced', 'Expert'],
                gridcolor: "#ecf0f1",
                tickcolor: "#ecf0f1",
                linecolor: "#929292",
                color: "black"
            },
            angularaxis: { color: 'black' }
        },
        showlegend: false,
        plot_bgcolor: 'rgba(0,0,0,0)',
        paper_bgcolor: 'rgba(0,0,0,0)',
        font: { color: 'black', size: '1.1em' },
        margin: { l: 50, r: 50, t: 50, b: 50 }
    };

    const config = { responsive: true, displayModeBar: false };
    Plotly.newPlot('languagesChart', [languageTrace], languageLayout, config);
    Plotly.newPlot('technicalChart', [technicalTrace], technicalLayout, config);
}

function createDegreeSection() {
    const container = document.getElementById('degreeContent');
    let html = '';

    // Add degrees

    RESUME_DATA.Education.Degrees.forEach(degree => {
        const duration = `${degree["Start Month"]} - ${degree["End Month"]}`;
        html += `
            <div class="col-md-12">
                <div class="education-item">
                    <h3>${degree.Degree}</h3>
                    <div class="school">${degree.School}</div>
                    <div class="highlight">${degree["Field of Study"]}</div>
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}

function createCerificationsSection() {
    const container = document.getElementById('certContent');
    let html = '';

    RESUME_DATA.Education.Certifications.forEach(cert => {
        html += `
            <div class="col-md-12">
                <div class="education-item">
                    <h3>${cert.Name}</h3>
                    <div class="school">${cert.Organization}</div>
                    <div>Issue Date: ${cert["Issue Date"]}</div>
                    <a href="${cert["Credential URL"]}" target="_blank" class="education-link">Credential ID: ${cert["Credential ID"]}</a>
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}

function createToolsSection() {
    const container = document.getElementById('toolsContent');
    let html = '';

    Object.entries(RESUME_DATA.Skills.Tools).forEach(([category, tools]) => {
        html += `
            <div class="tool-category">
                <h3>${category}</h3>
                <div class="grid-list">
                    ${tools.map(tool => `<span class="tool-tag">${tool}</span>`).join('')}
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}

// Group jobs by company
function groupJobsByCompany(jobs) {
    const companiesMap = new Map();
    
    jobs.forEach(job => {
        if (!companiesMap.has(job.Company)) {
            companiesMap.set(job.Company, []);
        }
        companiesMap.get(job.Company).push(job);
    });
    
    // Sort jobs within each company by start date (oldest first)
    companiesMap.forEach(jobs => {
        jobs.sort((a, b) => {
            const dateA = new Date(convertMonthToDate(a["Start Month"]));
            const dateB = new Date(convertMonthToDate(b["Start Month"]));
            return dateA - dateB;
        });
    });
    
    return companiesMap;
}

// Helper function to convert month format (e.g., "Jan-2022") to a date
function convertMonthToDate(monthStr) {
    if (monthStr === "Present") {
        return new Date();
    }
    
    const months = {
        "Jan": 0, "Feb": 1, "Mar": 2, "Apr": 3, "May": 4, "Jun": 5,
        "Jul": 6, "Aug": 7, "Sep": 8, "Oct": 9, "Nov": 10, "Dec": 11
    };
    
    const [month, year] = monthStr.split("-");
    return new Date(parseInt(year), months[month], 1);
}

function calculateJobMonths(jobObject) {
    const parseDate = (dateStr) => {
        // Handle current employment
        if (dateStr.toLowerCase() === 'present' || dateStr.toLowerCase() === 'current') {
            const now = new Date();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const currentMonth = monthNames[now.getMonth() + 1];
            const currentYear = now.getFullYear();
            dateStr = `${currentMonth}-${currentYear}`;
        }
        const [month, year] = dateStr.split('-');
        const months = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6, 
            'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12 };
        const jobMonths = new Date(parseInt(year) > 99 ? parseInt(year) : 2000 + parseInt(year), months[month])
        return jobMonths;
    };
    
    const start = parseDate(jobObject["Start Month"]);
    const end = parseDate(jobObject["End Month"]);
    
    return (end.getFullYear() - start.getFullYear()) * 12 + end.getMonth() - start.getMonth();
}

// State management
let activeFilters = new Set();
let allCategories = new Set();

// Group jobs by company
function groupJobsByCompany(jobs) {
    const companiesMap = new Map();
    
    jobs.forEach(job => {
        if (!companiesMap.has(job.Company)) {
            companiesMap.set(job.Company, []);
        }
        companiesMap.get(job.Company).push(job);
    });
    
    // Sort jobs within each company by start date (oldest first)
    companiesMap.forEach(jobs => {
        jobs.sort((a, b) => {
            const dateA = new Date(convertMonthToDate(a["Start Month"]));
            const dateB = new Date(convertMonthToDate(b["Start Month"]));
            return dateA - dateB;
        });
    });
    
    return companiesMap;
}

// Helper function to convert month format (e.g., "Jan-2022") to a date
function convertMonthToDate(monthStr) {
    if (monthStr === "Present") {
        return new Date();
    }
    
    const months = {
        "Jan": 0, "Feb": 1, "Mar": 2, "Apr": 3, "May": 4, "Jun": 5,
        "Jul": 6, "Aug": 7, "Sep": 8, "Oct": 9, "Nov": 10, "Dec": 11
    };
    
    const [month, year] = monthStr.split("-");
    return new Date(parseInt(year), months[month], 1);
}

// Extract all unique categories from job data
function extractCategories(jobs) {
    const categories = new Set();
    jobs.forEach(job => {
        job.Accomplishments.forEach(accomplishment => {
            accomplishment.Categories.forEach(category => {
                categories.add(category);
            });
        });
    });
    return Array.from(categories).sort();
}

// Format category name for CSS class
function getCategoryClass(category) {
    return `category-${category.toLowerCase().replace(/\s+/g, '-')}`;
}

// Create category pill element
function createCategoryPill(category, isFilter = false) {
    const pill = document.createElement('span');
    pill.className = `category-pill ${getCategoryClass(category)} ${isFilter ? 'filter-pill' : 'accomplishment-pill'}`;
    pill.textContent = category;
    
    if (isFilter) {
        pill.setAttribute('role', 'button');
        pill.setAttribute('tabindex', '0');
        pill.setAttribute('aria-pressed', 'false');
        pill.setAttribute('aria-label', `Filter by ${category}`);
        pill.onclick = () => toggleFilter(category);
        pill.onkeydown = (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                toggleFilter(category);
            }
        };
    }
    
    return pill;
}

// Toggle category filter
function toggleFilter(category) {
    const filterPill = document.querySelector(`.filter-pill.${getCategoryClass(category)}`);
    
    if (activeFilters.has(category)) {
        activeFilters.delete(category);
        filterPill.classList.remove('active');
        filterPill.setAttribute('aria-pressed', 'false');
    } else {
        activeFilters.add(category);
        filterPill.classList.add('active');
        filterPill.setAttribute('aria-pressed', 'true');
    }
    
    applyFilters();
    updateClearButton();
}

// Clear all filters
function clearAllFilters() {
    activeFilters.clear();
    document.querySelectorAll('.filter-pill').forEach(pill => {
        pill.classList.remove('active');
        pill.setAttribute('aria-pressed', 'false');
    });
    applyFilters();
    updateClearButton();
}

// Update clear button visibility
function updateClearButton() {
    const clearBtn = document.getElementById('clear-filters-btn');
    if (activeFilters.size > 0) {
        clearBtn.classList.remove('hidden');
    } else {
        clearBtn.classList.add('hidden');
    }
}

// Apply filters to accomplishments
function applyFilters() {
    const accomplishments = document.querySelectorAll('.accomplishment-item');
    const jobCards = document.querySelectorAll('.job-card');
    const companies = document.querySelectorAll('.company-container');
    let hasVisibleContent = false;
    
    if (activeFilters.size === 0) {
        // No filters active - show everything
        accomplishments.forEach(item => item.classList.remove('hidden'));
        jobCards.forEach(card => card.classList.remove('hidden'));
        companies.forEach(company => company.classList.remove('filtered-out'));
        document.getElementById('no-results').classList.remove('visible');
        return;
    }
    
    // Apply filters
    accomplishments.forEach(item => {
        const categories = item.getAttribute('data-categories').split(',');
        const matches = categories.some(cat => activeFilters.has(cat));
        
        if (matches) {
            item.classList.remove('hidden');
            hasVisibleContent = true;
        } else {
            item.classList.add('hidden');
        }
    });
    
    // Hide job cards with no visible accomplishments
    jobCards.forEach(card => {
        const visibleAccomplishments = card.querySelectorAll('.accomplishment-item:not(.hidden)');
        if (visibleAccomplishments.length === 0) {
            card.classList.add('hidden');
        } else {
            card.classList.remove('hidden');
        }
    });
    
    // Fade out companies with no visible job cards
    companies.forEach(company => {
        const visibleCards = company.querySelectorAll('.job-card:not(.hidden)');
        if (visibleCards.length === 0) {
            company.classList.add('filtered-out');
        } else {
            company.classList.remove('filtered-out');
        }
    });
    
    // Show/hide no results message
    if (hasVisibleContent) {
        document.getElementById('no-results').classList.remove('visible');
    } else {
        document.getElementById('no-results').classList.add('visible');
    }
}

// Render category filters
function renderCategoryFilters() {
    const filterContainer = document.getElementById('category-filters');
    const categories = extractCategories(RESUME_DATA.Jobs);
    
    // Insert filter pills before the clear button
    const clearBtn = document.getElementById('clear-filters-btn');
    categories.forEach(category => {
        const pill = createCategoryPill(category, true);
        filterContainer.insertBefore(pill, clearBtn);
        allCategories.add(category);
    });
}

// Render the job experience
function renderJobExperience() {
    const container = document.getElementById("experience-container");
    const groupedJobs = groupJobsByCompany(RESUME_DATA.Jobs);
    
    // Create company sections
    groupedJobs.forEach((jobs, companyName) => {
        // Get the first and last dates for company duration
        const firstJob = jobs[0];
        const lastJob = jobs[jobs.length - 1];
        const startMonth = firstJob["Start Month"];
        const endMonth = lastJob["End Month"];
        const icon = lastJob.icon || "fa-building";
        
        // Create company container
        const companyContainer = document.createElement("div");
        companyContainer.className = "company-container";
        
        // Create company header
        const companyHeader = document.createElement("div");
        companyHeader.className = "company-header";
        companyHeader.innerHTML = `
            <div class="company-icon">
                <i class="fas ${icon}"></i>
            </div>
            <div class="company-info">
                <div class="company-name">${companyName}</div>
                <div class="company-duration">${startMonth} - ${endMonth}</div>
            </div>
        `;
        
        // Create job cards container
        const jobCards = document.createElement("div");
        jobCards.className = "job-cards";
        
        // Add job cards (in reverse chronological order - newest first)
        jobs.slice().reverse().forEach(job => {
            const jobCard = document.createElement("div");
            jobCard.className = "job-card";
            companyHeader.style.background = `linear-gradient(to left, ${job.color}, rgba(255, 255, 255, 0.9))`;
            companyContainer.style.borderLeft = `4px solid ${job.color}`;

            // Create job title and duration
            const jobTitle = document.createElement("h3");
            jobTitle.className = "job-title";
            jobTitle.textContent = job["Job Title"];
            
            const jobDuration = document.createElement("span");
            jobDuration.className = "job-duration";
            jobDuration.textContent = `${job["Start Month"]} - ${job["End Month"]}`;
            
            // Create accomplishments list
            const accomplishmentsList = document.createElement("ul");
            accomplishmentsList.className = "accomplishments";
            
            job.Accomplishments.forEach(accomplishment => {
                const listItem = document.createElement("li");
                listItem.className = "accomplishment-item";
                listItem.setAttribute('data-categories', accomplishment.Categories.join(','));
                
                // Create accomplishment text span
                const textSpan = document.createElement("span");
                textSpan.className = "accomplishment-text";
                // Check if there's a link to insert
                if (accomplishment.Link) {
                    // Split the description at the link text
                    const parts = accomplishment.Description.split(accomplishment.Link.text);
                    
                    // Create the text with embedded link
                    textSpan.innerHTML = parts[0] + 
                        `<a href="${accomplishment.Link.url}" target="_blank" rel="noopener noreferrer" style="color: #3498DB; text-decoration: underline;">` +
                        accomplishment.Link.text + 
                        '</a>' + 
                        (parts[1] || '');
                } else {
                    textSpan.textContent = accomplishment.Description;
                }
                
                // Create categories container
                const categoriesSpan = document.createElement("span");
                categoriesSpan.className = "accomplishment-categories";
                
                // Add category pills
                accomplishment.Categories.forEach(category => {
                    const pill = createCategoryPill(category, false);
                    categoriesSpan.appendChild(pill);
                });
                
                listItem.appendChild(textSpan);
                listItem.appendChild(categoriesSpan);
                accomplishmentsList.appendChild(listItem);
            });
            
            // Append elements to job card
            jobCard.appendChild(jobTitle);
            jobCard.appendChild(jobDuration);
            jobCard.appendChild(accomplishmentsList);
            
            // Append job card to job cards container
            jobCards.appendChild(jobCard);
        });
        
        // Append company header and job cards to company container
        companyContainer.appendChild(companyHeader);
        companyContainer.appendChild(jobCards);
        
        // Append company container to main container
        container.appendChild(companyContainer);
    });
}

function calculateStats() {
    const totalJobs = RESUME_DATA.Jobs.length;
    const totalMonths = RESUME_DATA.Jobs.reduce((sum, job) => sum + calculateJobMonths(job), 0);
    const totalYears = Math.round((totalMonths / 12) * 10) / 10; // Round to 1 decimal place
    const totalCompanies = new Set(RESUME_DATA.Jobs.map(job => job.Company)).size;
    console.log(totalJobs);
    return {
        totalJobs,
        totalMonths: Math.round(totalMonths),
        totalYears,
        totalCompanies: totalCompanies
    };
}

function updateStatsDisplay(stats) {
    document.getElementById('totalJobs').textContent = stats.totalJobs;
    document.getElementById('totalYears').textContent = stats.totalYears;
    document.getElementById('totalCompanies').textContent = stats.totalCompanies;
}

// INITIALIZATION
function initDashboard() {
    renderCategoryFilters();
    renderJobExperience();
    const stats = calculateStats();
    console.log(stats);
    updateStatsDisplay(stats);
    createJobsChart();
    createSkillsCharts();
    createDegreeSection();
    createCerificationsSection();
    createToolsSection();
}

// Initialize dashboard when page loads
document.addEventListener('DOMContentLoaded', initDashboard);

// Handle window resize for responsive charts
window.addEventListener('resize', function() {
    Plotly.Plots.resize('jobsChart');
    Plotly.Plots.resize('languagesChart');
    Plotly.Plots.resize('technicalChart');
});